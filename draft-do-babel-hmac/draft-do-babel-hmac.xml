<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="no" ?>
<rfc category="std" docName="draft-do-babel-hmac"
     ipr="trust200902"
     updates="6126bis"
     obsoletes="7298">
<front>
<title>Babel Cryptographic Authentification</title>
<author fullname="Clara Do" initials="C." surname="Do">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street></street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>clarado_perso@yahoo.fr</email>
</address>
</author>
<author fullname="Weronika Kolodziejak" initials="W." surname="Kolodziejak">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street></street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>weronika.kolodziejak@gmail.com</email>
</address>
</author>
<author fullname="Juliusz Chroboczek" initials="J." surname="Chroboczek">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street>Case 7014</street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>jch@irif.fr</email>
</address>
</author>

<date day="2" month="July" year="2018"/>

<abstract>
<t></t>
</abstract>
</front>

<middle>

<section title="Introduction">

<t>By default, the Babel routing protocol trusts the information contained
in every UDP packet it receives on the Babel port.  If an attacker is
allowed to send such a packet, the attacker can redirect traffic to itself
or to a different node in the network, causing a variety of potential
issues.  In particular, and attacker could:
<list style="symbols">
<t>spoof a Babel packet, and redirect traffic by announcing a smaller
metric, a larger seqno, or a longer prefix;</t>
<t>spoof an incorrect packet, which could cause an insufficiently robust
implementation to crash or interfere with the rest of the network;</t>
<t>replay a previously captured Babel packet, which could cause traffic to
be redirected or otherwise interfere with the network.</t>
</list></t>

<t>Protecting a Babel network is made challenging by the fact that the
Babel protocol uses both unicast and multicast communication.  One
approach, used by the Babel over DTLS protocol, is to require a secured
version of Babel to use unicast communication for all semantically
significant communication, and then use a standard unicast security
protocol to protect the Babel traffic.  In this document, we define
a cryptographic extension to the Babel protocol that is able to protect
both unicast and multicast traffic, thus requiring little or no changes to
the core protocol.</t>

<section title="Applicability">

<t>The protocol defined in this document assumes that all interfaces on
a given link are equally trusted and share a small set of symmetric keys
(typically just one or two).  The protocol is inapplicable in situations
where asymmetric keying is required, where the trust relationship is
partial, or where large numbers of trusted keys are provisioned at the
same time on a single link.</t>

<t>The protocol supports incremental deployment (where an insecure Babel
network is made secure with no service interruption), and it supports
graceful key rotation (where the set of keys is changed with no service
interruption).</t>

<t>The protocol does not require synchronised clocks, it does not require
persistently monotonic clocks, and it does not require any form of
persistent storage.</t>

</section>

<section title="Assumptions and security properties">

<t>The correctness of the protocol relies on the following assumptions:
<list style="symbols">
<t>that the HMAC being used is invulnerable to spoofing, i.e.&nbsp;that an
attacker is unable to generate a packet with a correct HMAC;</t>
<t>that a node never generates the same index or nonce twice over the
lifetime of a key.</t>
</list>
The first assumption is a property of the HMAC under use.  The second
assumption can be met either by using a reliable random number generator
with sufficiently large values, by using a reliable hardware clock, or by
rekeying whenever a collision becomes likely.</t>

<t>If the assumptions above are met, the protocol described in this
document has the following properties:
<list style="symbols">
<t>it is invulnerable to spoofing: any packet accepted as authentic is the
exact copy of a packet originally sent by an authentic node;</t>
<t>within a single node, it is invulnerable to replay: if a node has
previously accepted a given packet as authentic, then it will never again
accept a copy of this packet as authentic;</t>
<t>among different nodes, it is only vulnerable to immediate replay: if
a node A has accepted a packet from C as valid, then a node B will only
accept a copy of that packet as authentic if B has accepted an older
packet from C and B has received no later packet from C.</t>
</list></t>

<t>While this protocol makes serious efforts to mitigate the effects of
a denial of service attack, it does not fully protect against such
attacks.</t>

</section>

</section>

<section title="Conceptual overview of the protocol">

</section>

<section title="Data Structures">

<t>TBD.  There's now a set of HMAC configured on each interface, an
index/seqno pair in each interface, an index/seqno pair in each neighbour
entry.  Additionally, each neighbour entry contains information about
a challenge in progress, a nonce and a timer.</t>

</section>

<section title="Protocol Operation">

<section title="HMAC computation" anchor="hmac-computation">

<t>TBD.  Construct the pseudo-header, append the pseudo-header to the
packet excluding the trailer (from octet 0 up to octet 4 + length), hash
the lot.  Describe the pseudo-header here, reference RFC&nbsp;6234, say
MUST implement HMAC-SHA256 as MTI, say SHOULD implement HMAC-SHA1.</t>

</section>

<section title="Message Transmission">

<t>A Babel node is expected to accumulate TLVs into a buffer in order to
send multiple TLVs in a single packet.  The buffer is flushed, and the
packet sent out, either after a timeout or when the buffer is about to
reach the MTU of the outgoing interface (Section 4 of rfc6126bis).</t>

<t>For an interface on which HMAC protection is configured, the packet is
terminated when it is small enough to allow appending one Crypto Seqno TLV
and the required number of HMAC TLVs (one per configured key) without
exceeding.  Before shipping out the packet, the following actions are
performed:
<list style="symbols">
<t>a Crypto Seqno TLV containing the Packet Counter and Index associated
with the outgoing interface is appended to the packet body; the packet
counter is incremented by one; if the packet counter overflows, a new
nonce is generated;</t>
<t>for each key configured on the interface, an HMAC is computed as
specified in <xref target="hmac-computation"/> above, and an HMAC TLV is
appended to the packet trailer.</t>
</list></t>

</section>

<section title="Message Reception">

<t>When a packet is received on an interface that is configured for HMAC
protection, the following steps are performed before the packet is passed
to normal processing:
</t>
<t>
<list style="symbols">
<t>First, the receiver checks whether the trailer of the received packet
carries at least one HMAC TLV; if not, the packet is immediately dropped
and processing stops.  Then, for each key configured on the receiving
interface, the implementation computes the HMAC of the packet.  It then
compares every generated HMAC against every HMAC included in the packet;
if there is at least one match, the packet passes the HMAC test; if there
is none, the packet is silently dropped and processing stops at this
point.  In order to avoid memory exhaustion attacks, an entry in the
Neighbour Table MUST NOT be created before the HMAC test has passed
successfully.  The HMAC of the packet MUST NOT be computed for each HMAC
TLV contained in the packet, but only once for each configured key.</t>
<t>The packet body is then parsed a first time.  During this "preparse"
phase, the packet body is traversed and all TLVs are ignored except
Cryptographic Seqno TLVs, Challenge Requests and Challenge Replies.  When
a Cryptographic Seqno TLV is encountered, the enclosed PC and Index are
saved for later processing; if multiple Cryptographic Seqnos are found,
only the first one is processed, the remaining ones are silently ignored.
If a Challenge Request is encountered, a Challenge Reply is scheduled, as
described in <xref target="replying-challenges"/>, and if a Challenge
Reply is encountered, it is tested for validity as described in <xref
target="receiving-challenges"/> and a note is made of the result of the
test.</t>
<t>The preparse phase above has yielded two pieces of data: the PC and
Index from the first Cryptographic Seqno TLV, and a bit indicating whether
the packet contained a successful Challenge Reply.  If the packet did not
contain a Cryptographic Seqno TLV, the packet is dropped and processing
stops at this point.  If the packet contained a successful Challenge
Reply, then the PC and Seqno contained in the Cryptographic Seqno TLV are
stored in the Neighbour Table entry corresponding to the sender (which may
need to be created at this stage).</t>
<t>If there is no entry in the Neighbour Table corresponding to the
sender, or if such an entry exists but contains no Index, or if the Index
it contains is different from the Index contained in the Cryptographic
Seqno TLV, then a challenge is sent as described in <xref
target="sending-challenges"/>, processing stops at this stage, and the
packet is silently dropped.</t>
<t>At this stage, the Index contained in the Cryptographic Seqno TLV is
equal to the Index in the Neighbour Table entry corresponding to the
sender.  The receiver compares the received PC with the PC contained in
the Neighbours table; if the received PC smaller or equal than the PC
contained in the neighbours table, the packet is silently dropped and
processing stops (no challenge is sent in this case, since this case might
be caused by some harmless packet reordering on the link).  Otherwise, the
PC contained in the Neighbour Table entry is set to the received PC, and
the packet is accepted.</t>
</list>
After the packet has been accepted, it is processed as normal, except that
any Cryptographic Seqno, Challenge Request and Challenge Reply TLVs it
contains are silently ignored.</t>

<section title="Challenge Requests and Replies">

<t>During the preparse stage, the receiver might encounter a mismatched
Index, to which it will react by schedling a Challenge Request.  It might
encounter a Challenge Request TLV, to which it will reply with a Challenge
Reply TLV.  Finally, it might encounter a Challenge Reply TLV, which it
will attempt to match with a previously sent Challenge Request TLV in
order to update the Neighbour Table entry corresponding to the sender of
the packet.</t>

<section title="Sending challenges" anchor="sending-challenges">

<t>When it encounters a mismatched Index during the preparse phase, a node
picks a nonce that it has never used before, for example by picking
a sufficiently large random strings of bytes or by consulting a strictly
monotonic hardware clock.  It stores the nonce in the entry of the
Neighbour Table corresponding to the neighbour (the entry might need to be
created at this stage), initialises the neighbour's challenge expiry
neighbour to 30 seconds, and sends a Challenge Request TLV to the unicast
address corresponding to the neighbour.</t>

<t>A node MAY aggregate a Challenge Request with other TLVs; in other
words, if it has already buffered TLVs to be sent to the unicast address
of the sender of the neighbour, it MAY send the buffered TLVs in the same
packet as the Challenge Request.  However, it MUST arrange for the
Challenge Request to be sent in a timely manner, as any packets received
from that neighbour will be silently ignored until the challenge
completes.</t>

</section>

<section title="Replying to challenges" anchor="replying-challenges">

<t>When it encounters a Challenge Request during the preparse phase,
a node constructs a Challenge Reply TLV by copying the Nonce from the
Challenge Request into the Challenge Reply.  It sends the Challenge Reply
to the unicast address of the sender of the Challenge Reply.</t>

<t>A node MAY aggregate a Challenge Reply with other TLVs; in other words,
if it has already buffered TLVs to be sent to the unicast address of the
sender of the Challenge Request, it MAY send the buffered TLVs in the same
packet as the Challenge Reply.  However, it MUST arrange for the Challenge
Reply to be sent in a timely manner (within a few seconds), and SHOULD NOT
send any other TLVs over the same interface before sending the Challenge
Reply, as those would be dropped by the challenger.</t>

</section>

<section title="Receiving challenge replies" anchor="receiving-challenges">

<t>When it encounters a Challenge Reply during the preparse phase, a nonce
consults the Neighbour Table entry corresponding to the neighbour that
sent the Challenge Reply.  If no challenge is in progress, i.e.&nbsp; if
there is no Nonce stored in the Neighbour Table entry or the Challenge
timer has expired, the Challenge Reply is silently ignored and the
challenge has failed.</t>

<t>Otherwise, the node compares the Nonce contained in the Challenge Reply
with the Nonce contained in the Neighbour Table entry.  If the two are
equal (they have the same length and the same contents), then the
challenge has succeeded; otherwise, the challenge has failed.</t>

</section>

</section>

</section>

</section>

<section title="Packet Format">

<t></t>

<section title="TLV HMAC Format">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     HMAC...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate an HMAC TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body depends on the hash function
used.</t>
<t hangText="HMAC">The body contains the HMAC of the whole packet
plus the pseudo header.</t>
</list></t>

</section>

<section title="TLV Cryptographic Seqno Format">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |             PC
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |            Index...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a Cryptographic Seqno TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.</t>
<t hangText="PC">Packet Counter.  Each time we send a packet, we must
increase the Packet Counter.  If the Packet Counter overflows it must
be set to 0 and a new Index must be randomly chosen. </t>
<t hangText="Index">Our chosen Index.  It must be randomly chosen every
time we lose state, or when the Packet Counter has reset.
</t>
</list></t>

</section>

<section title="TLV Challenge Request Format">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Nonce...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a Challenge Request TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body is set to a chosen high number
for maximum security (in general half of the size of the hash length).</t>
<t hangText="Nonce">A random number of an arbitrary size.</t>
</list></t>

</section>

<section title="TLV Challenge Reply Format">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Nonce...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a Challenge Reply TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body is set to the same size as the
challenge request TLV length received.</t>
<t hangText="Nonce">A copy of the nonce contained in the corresponding
challenge request.</t>
</list></t>
</section>

</section>

<section title="Security Considerations">

<t></t>

</section>

<section title="IANA Considerations">

</section>

<section title="Acknowledgments">

<t>The protocol described in this document is based on the original HMAC
protocol defined by Denis Ovsienko [RFC&nbsp;7298].  The use of
a pseudo-header was suggested by David Schinazi.  The use of an index to
avoid replay was suggested by Markus Stenberg.  The authors are also
indebted to Florian Horn and Toke Hoyland-Jorgensen.</t>

</section>

</middle>

<back>

<section title="Implicit indices">

<t>[This appendix describes the "implicit indices" variant of the
protocol, which is different and incompatible to the "explicit indices"
variant described in the body of this document.  This section should
either be integrated into the body of the document or be removed before
publication of this document an RFC, depending on which protocol variant
is finally chosen.]</t>

<t>The protocol described in the body of this document explicitly sends
indices as in each packet as part of the Cryptographic Seqno TLV.  Observe
that, except when a challenge is required, the index sent on the wire is
identical to the index stored in the Neighbour Table, and therefore
doesn't need to be sent explicitly except during challenges &mdash; it is
enough for it to participate in HMAC computation in order to protect
against replay.  The "implicit indices" variant of the protocol, due to
Markus Stenberg and described in this appendix, uses this information to
avoid sending indices explicitly and thus shave off 8 to 10 octets from
almost every packet.</t>

<t>The changes to the protocol are as follows.  The pseudo-header includes
the Index, and therefore has the following format:
<figure><artwork><![CDATA[
TBD
]]></artwork></figure>
</t>

<t>The Cryptographic Seqno TLV no longer contains an Index, and therefore
has the following format:
<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |             PC
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>
This TLV is now self-terminating, and therefore allows sub-TLVs.</t>

<t>Packets containing the Challenge Reply and Challenge Request TLVs must
contain an explicit index.  Two encodings are possible: one uses Challenge
Replies and Requests with an extra field for the sender's index, which
complicates the encoding somewhat but makes these two TLVs
self-terminating, the other one uses a new TLV that is used for carrying
an Index, which uses up a new TLV number but makes it possible to reuse
these two TLV with other protocols that require a nonce-based challenge.</t>

<t>Packet transmission is modified as follows.  If a packet contains
a Challenge or a Challenge Reply, then the node inserts its index into the
packet body.  In any case, it uses its current index to generate the
pseudo-header that will be used to compute the HMAC and shipping out the
packet.  (This implies that a packet must be parsed in its entirety before
HMAC validation, which requires a robust parser.)</t>

<t>Packet reception is modified as follows.  Before checking the HMAC of
a packet, the receiver checks whether the packet contains an explicit
index.  If this is the case, it uses the index contained in the packet in
order to generate the pseudo header; if this is not the case, it uses the
index contained in its neighbours table.  If there is no index available
for that neighbour (either because the table doesn't contain in an entry for
this neighbour, or the entry doesn't contain an index), HMAC validation
fails.</t>

<t>The index and cryptographic seqno contained in the neighbours table are
only updated after HMAC validation has succeeded.</t>

<t>Since it is now impossible to differenciate between a failed HMAC and
an index change, a node must send a challenge whenever HMAC validation
fails.  This implies that spoofed packets cause a spurious challenge, but
that doesn't change the security properties of the protocol much, given
that in any case replayed packets can be used to cause a spurious
challenge.</t>
  
</section>

</back>

</rfc>
