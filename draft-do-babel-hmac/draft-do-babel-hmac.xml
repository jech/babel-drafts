<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="no" ?>
<rfc category="std" docName="draft-do-babel-hmac"
     ipr="trust200902"
     updates="6126bis"
     obsoletes="7298">
<front>
<title>Babel Cryptographic Authentification</title>
<author fullname="Clara Do" initials="C." surname="Do">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street></street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>clarado_perso@yahoo.fr</email>
</address>
</author>
<author fullname="Weronika Kolodziejak" initials="W." surname="Kolodziejak">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street></street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>weronika.kolodziejak@gmail.com</email>
</address>
</author>
<author fullname="Juliusz Chroboczek" initials="J." surname="Chroboczek">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street>Case 7014</street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>jch@irif.fr</email>
</address>
</author>

<date day="2" month="July" year="2018"/>

<abstract>
<t>This document describes a cryptographic authentication mechanism for
the Babel routing protocol that has provisions for replay avoidance.  This
document updates RFC 6126bis and obsoletes RFC 7298.</t>
</abstract>

</front>

<middle>

<section title="Introduction">

<t>By default, the Babel routing protocol trusts the information contained
in every UDP packet it receives on the Babel port.  If an attacker is
allowed to send such a packet, the attacker can redirect traffic to itself
or to a different node in the network, causing a variety of potential
issues.  In particular, and attacker could:
<list style="symbols">
<t>spoof a Babel packet, and redirect traffic by announcing a smaller
metric, a larger seqno, or a longer prefix;</t>
<t>spoof an incorrect packet, which could cause an insufficiently robust
implementation to crash or interfere with the rest of the network;</t>
<t>replay a previously captured Babel packet, which could cause traffic to
be redirected or otherwise interfere with the network.</t>
</list></t>

<t>Protecting a Babel network is made challenging by the fact that the
Babel protocol uses both unicast and multicast communication.  One
approach, used by the Babel over DTLS protocol, is to require a secured
version of Babel to use unicast communication for all semantically
significant communication, and then use a standard unicast security
protocol to protect the Babel traffic.  In this document, we define
a cryptographic extension to the Babel protocol that is able to protect
both unicast and multicast traffic, thus requiring little or no changes to
the core protocol.</t>

<section title="Applicability">

<t>The protocol defined in this document assumes that all interfaces on
a given link are equally trusted and share a small set of symmetric keys
(typically just one or two).  The protocol is inapplicable in situations
where asymmetric keying is required, where the trust relationship is
partial, or where large numbers of trusted keys are provisioned at the
same time on a single link.</t>

<t>The protocol supports incremental deployment (where an insecure Babel
network is made secure with no service interruption), and it supports
graceful key rotation (where the set of keys is changed with no service
interruption).</t>

<t>The protocol does not require synchronised clocks, it does not require
persistently monotonic clocks, and it does not require any form of
persistent storage.</t>

</section>

<section title="Assumptions and security properties"
         anchor="security-properties">

<t>The correctness of the protocol relies on the following assumptions:
<list style="symbols">
<t>that the HMAC being used is invulnerable to spoofing, i.e.&nbsp;that an
attacker is unable to generate a packet with a correct HMAC;</t>
<t>that a node never generates the same index or nonce twice over the
lifetime of a key.</t>
</list>
The first assumption is a property of the HMAC under use.  The second
assumption can be met either by using a reliable random number generator
with sufficiently large values, by using a reliable hardware clock, or by
rekeying whenever a collision becomes likely.</t>

<t>If the assumptions above are met, the protocol described in this
document has the following properties:
<list style="symbols">
<t>it is invulnerable to spoofing: any packet accepted as authentic is the
exact copy of a packet originally sent by an authentic node;</t>
<t>within a single node, it is invulnerable to replay: if a node has
previously accepted a given packet as authentic, then it will never again
accept a copy of this packet as authentic;</t>
<t>among different nodes, it is only vulnerable to immediate replay: if
a node A has accepted a packet from C as valid, then a node B will only
accept a copy of that packet as authentic if B has accepted an older
packet from C and B has received no later packet from C.</t>
</list></t>

<t>While this protocol makes serious efforts to mitigate the effects of
a denial of service attack, it does not fully protect against such
attacks.</t>

</section>

</section>

<section title="Conceptual overview of the protocol">

<t>When a node B sends out a Babel packet through an interface that is
configured for cryptographic protection, it computes one or more HMACs
which it appends to the packet.  When a node A receives a packet over an
interface that requires cryptographic protection, it independently
computes a set of HMACs and compares them to the HMACs appended to the
packet; if there is no match, the packet is discarded.</t>

<t>In order to protect against replay, for every inteface B maintains
a 32-bit integer known as the "packet counter" (PC). Whenever B sends
a packet through the interface, it embeds the current value of the PC
within the region of the packet that is protected by the HMACs and
increases the PC by at least one.  When A receives the packet, it compares
the value of the PC with the one contained in the previous packet received
from B, and unless it is strictly larger, the packet is discarded.</t>

<t>By itself, the PC mechanism is not sufficient to protect against
replay.  Consider a pair A that has no information about a pair
B (e.g. because it has recently rebooted).  Suppose that A receives
a packet ostensibly from B carrying a given PC; since A has no information
about B, it has no way to determine whether the packet is freshly
generated or a replay of a previously sent packet.</t>

<t>In this situation, A discards the packet and challenges B to prove that
it knows the HMAC key.  It sends a "challenge request", a TLV containing
a nonce, a value that has never been used before and will never be used
again.  B replies to the challenge request with a "challenge reply", a TLV
containing a copy of the nonce chosen by A, in a packet protected by HMAC
and containing the next PC.  Since the nonce has never been used before,
B's reply proves B's knowledge of the HMAC key and the freshness of the
PC.</t>

<t>By itself, this mechanism is safe against replay only if B never resets
its PC.  In practice, however, this is difficult to ensure &mdash;
persistent storage is prone to failure, and hardware clocks, even when
available, are occasionally reset.  Suppose that B resets its PC to
a former value, and sends a packet with a previously used PC n.
A challenges B, B successfully responds to the challenge, A accepts the PC
equal to n&nbsp;+&nbsp;1.  At this point, an attacker C may send
a replayed packet with PC equal to n&nbsp;+&nbsp;2, which will be accepted
by A.</t>

<t>Another mechanism is needed to protect against this attack.  In this
protocol, every PC is tagged with an "index", an arbitrary string of
octets.  Whenever B resets its PC, or whenever B doesn't know whether its
PC has been reset, it picks an index that it has never used before (either
by drawing it randomly or by using a reliable hardware clock) and starts
sending PCs with that index.  Whenever A detects an index change, it
challenges B.</t>

<t>With the index mechanism, this protocol is provably invulnerable to
replay attacks (see <xref target="security-properties"/> above).</t>

</section>

<section title="Data Structures">

<t>TBD.  There's now a set of HMAC configured on each interface, an
index/seqno pair in each interface, an index/seqno pair in each neighbour
entry.  Additionally, each neighbour entry contains information about
a challenge in progress, a nonce and a timer.</t>

</section>

<section title="Protocol Operation">

<section title="HMAC computation" anchor="hmac-computation">

<t>TBD.  Construct the pseudo-header, append the pseudo-header to the
packet excluding the trailer (from octet 0 up to octet 4 + length), hash
the lot.  Describe the pseudo-header here, reference RFC&nbsp;6234, say
MUST implement HMAC-SHA256 as MTI, say SHOULD implement HMAC-SHA1.</t>

</section>

<section title="Packet Transmission">

<t>A Babel node may delay actually sending TLVs by a small amount, in
order to aggregate multiple TLVs in a single packet up to the interface
MTU (Section 4 of rfc6126bis).  For an interface on which HMAC protection
is configured, the TLV aggregation logic MUST take into account the
overhead due to PC TLVs (one in each packet) and HMAC TLVs (one per
configured key).</t>

<t>Before sending a packet, the following actions are performed:
<list style="symbols">
<t>a PC TLV containing the Packet Counter and Index associated with the
outgoing interface is appended to the packet body; the packet counter is
incremented by a strictly positive amount (typically just 1); if the
packet counter overflows, a new index is generated;</t>
<t>for each key configured on the interface, an HMAC is computed as
specified in <xref target="hmac-computation"/> above, and an HMAC TLV is
appended to the packet trailer.</t>
</list></t>

</section>

<section title="Packet Reception">

<t>When a packet is received on an interface that is configured for HMAC
protection, the following steps are performed before the packet is passed
to normal processing:
</t>
<t>
<list style="symbols">
<t>First, the receiver checks whether the trailer of the received packet
carries at least one HMAC TLV; if not, the packet is immediately dropped
and processing stops.  Then, for each key configured on the receiving
interface, the implementation computes the HMAC of the packet.  It then
compares every generated HMAC against every HMAC included in the packet;
if there is at least one match, the packet passes the HMAC test; if there
is none, the packet is silently dropped and processing stops at this
point.  In order to avoid memory exhaustion attacks, an entry in the
Neighbour Table MUST NOT be created before the HMAC test has passed
successfully.  The HMAC of the packet MUST NOT be computed for each HMAC
TLV contained in the packet, but only once for each configured key.</t>
<t>The packet body is then parsed a first time.  During this "preparse"
phase, the packet body is traversed and all TLVs are ignored except PC
TLVs, Challenge Requests and Challenge Replies.  When a PC TLV is
encountered, the enclosed PC and Index are saved for later processing; if
multiple PCs are found, only the first one is processed, the remaining
ones are silently ignored.  If a Challenge Request is encountered,
a Challenge Reply is scheduled, as described in <xref
target="replying-challenges"/>, and if a Challenge Reply is encountered,
it is tested for validity as described in <xref
target="receiving-challenges"/> and a note is made of the result of the
test.</t>
<t>The preparse phase above has yielded two pieces of data: the PC and
Index from the first PC TLV, and a bit indicating whether the packet
contained a successful Challenge Reply.  If the packet did not contain
a PC TLV, the packet is dropped and processing stops at this point.  If
the packet contained a successful Challenge Reply, then the PC and Index
contained in the PC TLV are stored in the Neighbour Table entry
corresponding to the sender (which may need to be created at this
stage).</t>
<t>If there is no entry in the Neighbour Table corresponding to the
sender, or if such an entry exists but contains no Index, or if the Index
it contains is different from the Index contained in the PC TLV, then
a challenge is sent as described in <xref target="sending-challenges"/>,
processing stops at this stage, and the packet is silently dropped.</t>
<t>At this stage, the Index contained in the PC TLV is equal to the Index
in the Neighbour Table entry corresponding to the sender.  The receiver
compares the received PC with the PC contained in the Neighbours table; if
the received PC smaller or equal than the PC contained in the neighbours
table, the packet is silently dropped and processing stops (no challenge
is sent in this case, since this case might be caused by some harmless
packet reordering on the link).  Otherwise, the PC contained in the
Neighbour Table entry is set to the received PC, and the packet is
accepted.</t>
</list>
After the packet has been accepted, it is processed as normal, except that
any PC, Challenge Request and Challenge Reply TLVs that it contains are
silently ignored.</t>

<section title="Challenge Requests and Replies">

<t>During the preparse stage, the receiver might encounter a mismatched
Index, to which it will react by schedling a Challenge Request.  It might
encounter a Challenge Request TLV, to which it will reply with a Challenge
Reply TLV.  Finally, it might encounter a Challenge Reply TLV, which it
will attempt to match with a previously sent Challenge Request TLV in
order to update the Neighbour Table entry corresponding to the sender of
the packet.</t>

<section title="Sending challenges" anchor="sending-challenges">

<t>When it encounters a mismatched Index during the preparse phase, a node
picks a nonce that it has never used before, for example by picking
a sufficiently large random strings of bytes or by consulting a strictly
monotonic hardware clock.  It stores the nonce in the entry of the
Neighbour Table corresponding to the neighbour (the entry might need to be
created at this stage), initialises the neighbour's challenge expiry
neighbour to 30 seconds, and sends a Challenge Request TLV to the unicast
address corresponding to the neighbour.</t>

<t>A node MAY aggregate a Challenge Request with other TLVs; in other
words, if it has already buffered TLVs to be sent to the unicast address
of the sender of the neighbour, it MAY send the buffered TLVs in the same
packet as the Challenge Request.  However, it MUST arrange for the
Challenge Request to be sent in a timely manner, as any packets received
from that neighbour will be silently ignored until the challenge
completes.</t>

</section>

<section title="Replying to challenges" anchor="replying-challenges">

<t>When it encounters a Challenge Request during the preparse phase,
a node constructs a Challenge Reply TLV by copying the Nonce from the
Challenge Request into the Challenge Reply.  It sends the Challenge Reply
to the unicast address of the sender of the Challenge Reply.</t>

<t>A node MAY aggregate a Challenge Reply with other TLVs; in other words,
if it has already buffered TLVs to be sent to the unicast address of the
sender of the Challenge Request, it MAY send the buffered TLVs in the same
packet as the Challenge Reply.  However, it MUST arrange for the Challenge
Reply to be sent in a timely manner (within a few seconds), and SHOULD NOT
send any other TLVs over the same interface before sending the Challenge
Reply, as those would be dropped by the challenger.</t>

</section>

<section title="Receiving challenge replies" anchor="receiving-challenges">

<t>When it encounters a Challenge Reply during the preparse phase, a nonce
consults the Neighbour Table entry corresponding to the neighbour that
sent the Challenge Reply.  If no challenge is in progress, i.e.&nbsp; if
there is no Nonce stored in the Neighbour Table entry or the Challenge
timer has expired, the Challenge Reply is silently ignored and the
challenge has failed.</t>

<t>Otherwise, the node compares the Nonce contained in the Challenge Reply
with the Nonce contained in the Neighbour Table entry.  If the two are
equal (they have the same length and the same contents), then the
challenge has succeeded; otherwise, the challenge has failed.</t>

</section>

</section>

</section>

</section>

<section title="Packet Format">

<t></t>

<section title="HMAC TLV">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     HMAC...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate an HMAC TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body depends on the hash function
used.</t>
<t hangText="HMAC">The body contains the HMAC of the whole packet
plus the pseudo header.</t>
</list></t>

</section>

<section title="PC TLV">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |             PC
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |            Index...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a PC TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.</t>
<t hangText="PC">Packet Counter.  Each time we send a packet, we must
increase the Packet Counter.  If the Packet Counter overflows it must
be set to 0 and a new Index must be randomly chosen. </t>
<t hangText="Index">Our chosen Index.  It must be randomly chosen every
time we lose state, or when the Packet Counter has reset.
</t>
</list></t>

</section>

<section title="Challenge Request TLV">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Nonce...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a Challenge Request TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body is set to a chosen high number
for maximum security (in general half of the size of the hash length).</t>
<t hangText="Nonce">A random number of an arbitrary size.</t>
</list></t>

</section>

<section title="Challenge Reply TLV">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Nonce...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a Challenge Reply TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body is set to the same size as the
challenge request TLV length received.</t>
<t hangText="Nonce">A copy of the nonce contained in the corresponding
challenge request.</t>
</list></t>
</section>

</section>

<section title="Security Considerations">

<t></t>

</section>

<section title="IANA Considerations">

<t>IANA is instructed to allocate the following values in the Babel TLV
Numbers registry:</t>
<texttable>
<ttcol>Type</ttcol><ttcol>Name</ttcol><ttcol>Reference</ttcol>
<c>TBD</c><c>HMAC</c><c>this document</c>
<c>TBD</c><c>Challenge Request</c><c>this document</c>
<c>TBD</c><c>Challenge Reply</c><c>this document</c>
</texttable>

</section>

<section title="Acknowledgments">

<t>The protocol described in this document is based on the original HMAC
protocol defined by Denis Ovsienko [RFC&nbsp;7298].  The use of
a pseudo-header was suggested by David Schinazi.  The use of an index to
avoid replay was suggested by Markus Stenberg.  The authors are also
indebted to Florian Horn and Toke Hoyland-Jorgensen.</t>

</section>

</middle>

<back>

<section title="Implicit indices">

<t>[This appendix describes the "implicit indices" variant of the
protocol, which is different and incompatible to the "explicit indices"
variant described in the body of this document.  This section should
either be integrated into the body of the document or be removed before
publication of this document an RFC, depending on which protocol variant
is finally chosen.]</t>

<t>The protocol described in the body of this document explicitly sends
indices as in each packet as part of the PC TLV.  Observe that, except
when a challenge is required, the index sent on the wire is identical to
the index stored in the Neighbour Table, and therefore doesn't need to be
sent explicitly except during challenges &mdash; it is enough for it to
participate in HMAC computation in order to protect against replay.  The
"implicit indices" variant of the protocol, due to Markus Stenberg and
described in this appendix, uses this information to avoid sending indices
explicitly and thus shave off 8 to 10 octets from almost every packet.</t>

<t>The changes to the protocol are as follows.  The pseudo-header includes
the Index, and therefore has the following format:
<figure><artwork><![CDATA[
TBD
]]></artwork></figure>
</t>

<t>The PC TLV no longer contains an Index, and therefore has the following
format:
<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |             PC
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>
This TLV is now self-terminating, and therefore allows sub-TLVs.</t>

<t>Packets containing the Challenge Reply and Challenge Request TLVs must
contain an explicit index.  Two encodings are possible: one uses Challenge
Replies and Requests with an extra field for the sender's index, which
complicates the encoding somewhat but makes these two TLVs
self-terminating, the other one uses a new TLV that is used for carrying
an Index, which uses up a new TLV number but makes it possible to reuse
these two TLV with other protocols that require a nonce-based challenge.</t>

<t>Packet transmission is modified as follows.  If a packet contains
a Challenge or a Challenge Reply, then the node inserts its index into the
packet body.  In any case, it uses its current index to generate the
pseudo-header that will be used to compute the HMAC and shipping out the
packet.  (This implies that a packet must be parsed in its entirety before
HMAC validation, which requires a robust parser.)</t>

<t>Packet reception is modified as follows.  Before checking the HMAC of
a packet, the receiver checks whether the packet contains an explicit
index.  If this is the case, it uses the index contained in the packet in
order to generate the pseudo header; if this is not the case, it uses the
index contained in its neighbours table.  If there is no index available
for that neighbour (either because the table doesn't contain in an entry for
this neighbour, or the entry doesn't contain an index), HMAC validation
fails.</t>

<t>The index and PC contained in the neighbours table are only updated
after HMAC validation has succeeded.</t>

<t>Since it is now impossible to differenciate between a failed HMAC and
an index change, a node must send a challenge whenever HMAC validation
fails.  This implies that spoofed packets cause a spurious challenge, but
that doesn't change the security properties of the protocol much, given
that in any case replayed packets can be used to cause a spurious
challenge.</t>
  
</section>

</back>

</rfc>
