<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" []>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="no" ?>
<rfc category="std" docName="draft-do-babel-hmac"
     ipr="trust200902"
     obsoletes="6126,7557">
<front>
<title>Babel Cryptographic Authentification</title>
<author fullname="Clara Do" initials="C." surname="Do">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street></street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>clarado_perso@yahoo.fr</email>
</address>
</author>
<author fullname="Weronika Kolodziejak" initials="W." surname="Kolodziejak">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street></street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>weronika.kolodziejak@gmail.com</email>
</address>
</author>
<author fullname="Juliusz Chroboczek" initials="J." surname="Chroboczek">
<organization>IRIF, University of Paris-Diderot</organization>
<address>
<postal>
<street>Case 7014</street>
<city>75205 Paris Cedex 13</city>
<region></region>
<code></code>
<country>France</country>
</postal>
<email>jch@irif.fr</email>
</address>
</author>

<date day="29" month="June" year="2018"/>

<abstract>
<t></t>
</abstract>
</front>

<middle>

<section title="Introduction">

<t>By default, the Babel routing protocol trusts the information contained
in every UDP packet it receives on the Babel port.  If an attacker is
allowed to send such a packet, the attacker can redirect traffic to itself
or to a different node in the network, causing a variety of potential
issues.  In particular, and attacker could:
<list style="symbols">
<t>spoof a Babel packet, and redirect traffic by announcing a smaller
metric, a larger seqno, or a longer prefix;</t>
<t>spoof an incorrect packet, which could cause an insufficiently robust
implementation to crash or interfere with the rest of the network;</t>
<t>replay a previously captured Babel packet, which could cause traffic to
be redirected or otherwise interfere with the network.</t>
</list></t>

<t>Protecting a Babel network is made challenging by the fact that the
Babel protocol uses both unicast and multicast communication.  One
approach, used by the Babel over DTLS protocol, is to require a secured
version of Babel to use unicast communication for all semantically
significant communication, and then use a standard unicast security
protocol to protect the Babel traffic.  In this document, we define
a cryptographic extension to the Babel protocol that is able to protect
both unicast and multicast traffic, thus requiring little or no changes to
the core protocol.</t>

<section title="Applicability">

<t>The protocol defined in this document assumes that all interfaces on
a given link are equally trusted and share a small set of symmetric keys
(typically just one or two).  The protocol is inapplicable in situations
where asymmetric keying is required, where the trust relationship is
partial, or where large numbers of trusted keys are provisioned at the
same time on a single link.</t>

<t>The protocol supports incremental deployment (where an insecure Babel
network is made secure with no service interruption), and it supports
graceful key rotation (where the set of keys is changed with no service
interruption).</t>

<t>The protocol does not require synchronised clocks, it does not require
persistently monotonic clocks, and it does not require any form of
persistent storage.</t>

</section>

<section title="Assumptions and security properties">

<t>The correctness of the protocol relies on the following assumptions:
<list style="symbols">
<t>that the HMAC being used is invulnerable to spoofing, i.e.&nbsp;that an
attacker is unable to generate a packet with a correct HMAC;</t>
<t>that a node never generates the same index or nonce twice over the
lifetime of a key.</t>
</list>
The first assumption is a property of the HMAC under use.  The second
assumption can be met either by using a reliable random number generator
with sufficiently large values, by using a reliable hardware clock, or by
rekeying whenever a collision becomes likely.</t>

<t>If the assumptions above are met, the protocol described in this
document has the following properties:
<list style="symbols">
<t>it is invulnerable to spoofing: any packet accepted as authentic is the
exact copy of a packet originally sent by an authentic node;</t>
<t>within a single node, it is invulnerable to replay: if a node has
previously accepted a given packet as authentic, then it will never again
accept a copy of this packet as authentic;</t>
<t>among different nodes, it is only vulnerable to immediate replay: if
a node A has accepted a packet from C as valid, then a node B will only
accept a copy of that packet as authentic if B has accepted an older
packet from C and B has received no later packet from C.</t>
</list></t>

<t>While this protocol makes serious efforts to mitigate the effects of
a denial of service attack, it does not fully protect against such
attacks.</t>

</section>

</section>

<section title="Data Structures">

<t></t>

</section>

<section title="Protocol Operation">

<section title="Message Transmission">
<t>
<list style="symbols">
<t>In order to prevent replay, a Babel implementation must include an Index
and a per interface Packet Counter.  When sending a packet, a TLV containing
the Index and the Packet Counter is added in the body.  The Packet Conter
increase.  If the Packet Counter overflows, a new Index is randomly chosen.</t>
<t> The pseudo header is determined and the HMAC calculated (eventually two
different HMAC during key rotation).  The HMAC must be placed in the packet
trailer. </t>
</list>

</t>

</section>

<section title="Message Reception">

<t>When receiving a packet, the security verification proceed in three steps:
</t>
<t>
<list style="symbols">
<t>A Babel implementation must first check if at least one  HMAC received is
correct.  We generate an HMAC from the body of the packet (remove header and
trailer), and the pseudo header with the key corresponding to the interface.
When we receive packet with a wrong HMAC or no HMAC (if a key is added to the
corresponding interface), the packet must be silently ignore.  If the HMAC has
the right value, we know for sure that the packet were sent by a trusted
identity.  However, it still can be a replayed packet.</t>
<t>A Babel implementation must preparse the packet after the HMAC verification,
in order to detect replay.  We are looking for the Index and Packet Counter,
the challenge reply (when we previously asked the neighbour) and eventually a
challenge request.  A challenge request should be treated immediatley to prevent
latency.  A lack of Index and Packet Counter, or an unknown Index must send a
challenge to the corresponding neighbour and reject the packet.  A wrong Packet
Counter (while receiving a correct Index) must reject the packet without
sending a challenge request.  A wrong reply to the challenge must reject the
packet.  When the reply to the challenge is correct, the Babel implementation
must retrieve and memorize the Index and the Packet Counter and continue
parsing.</t>
<t>The rest of the parsing is left as described in rfc???</t>
</list>

</t>

</section>

</section>

<section title="Packet Format">

<t></t>

<section title="TLV HMAC Format">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     HMAC...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate an HMAC TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body depends on the hash function
used.</t>
<t hangText="HMAC">The body contains the HMAC of the whole packet
plus the pseudo header.</t>
</list></t>

</section>

<section title="TLV Cryptographic Seqno Format">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |             PC
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |            Index...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a Cryptographic Seqno TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.</t>
<t hangText="PC">Packet Counter.  Each time we send a packet, we must
increase the Packet Counter.  If the Packet Counter overflows it must
be set to 0 and a new Index must be randomly chosen. </t>
<t hangText="Index">Our chosen Index.  It must be randomly chosen every
time we lose state, or when the Packet Counter has reset.
</t>
</list></t>

</section>

<section title="TLV Challenge Request Format">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Nonce...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a Challenge Request TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body is set to a chosen high number
for maximum security (in general half of the size of the hash length).</t>
<t hangText="Nonce">A random number of an arbitrary size.</t>
</list></t>

</section>

<section title="TLV Challenge Reply Format">

<t></t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |     Nonce...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
]]></artwork></figure>

<t>Fields :
<list style="hanging" hangIndent="10">
<t hangText="Type">Set to TBD to indicate a Challenge Reply TLV</t>
<t hangText="Length">The length of the body, exclusive of the Type and
Length fields.  The length of the body is set to the same size as the
challenge request TLV length received.</t>
<t hangText="Nonce">A copy of the nonce contained in the corresponding
challenge request.</t>
</list></t>
</section>

</section>

<section title="Security Considerations">

<t></t>

</section>

<section title="IANA Considerations">

</section>

<section title="Acknowledgments">

</section>

</middle>

<back>

<section title="Implicit indices">

<t>[This appendix describes the "implicit indices" variant of the
protocol, which is different and incompatible to the "explicit indices"
variant described in the body of this document.  This section should
either be integrated into the body of the document or be removed before
publication of this document an RFC, depending on which protocol variant
is finally chosen.]</t>

<t>The protocol described in the body of this document explicitly sends
indices as in each packet as part of the Cryptographic Seqno TLV.  Observe
that, except when a challenge is required, the index sent on the wire is
identical to the index stored in the Neighbour Table, and therefore
doesn't need to be sent explicitly except during challenges &mdash; it is
enough for it to participate in HMAC computation in order to protect
against replay.  The "implicit indices" variant of the protocol, due to
Markus Stenberg and described in this appendix, uses this information to
avoid sending indices explicitly and thus shave off 8 to 10 octets from
almost every packet.</t>

<t>The changes to the protocol are as follows.  The pseudo-header includes
the Index, and therefore has the following format:
<figure><artwork><![CDATA[
TBD
]]></artwork></figure>
</t>

<t>The Cryptographic Seqno TLV no longer contains an Index, and therefore
has the following format:
<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Type      |    Length     |             PC
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>
This TLV is now self-terminating, and therefore allows sub-TLVs.</t>

<t>Packets containing the Challenge Reply and Challenge Request TLVs must
contain an explicit index.  Two encodings are possible: one uses Challenge
Replies and Requests with an extra field for the sender's index, which
complicates the encoding somewhat but makes these two TLVs
self-terminating, the other one uses a new TLV that is used for carrying
an Index, which uses up a new TLV number but makes it possible to reuse
these two TLV with other protocols that require a nonce-based challenge.</t>

<t>Packet transmission is modified as follows.  If a packet contains
a Challenge or a Challenge Reply, then the node inserts its index into the
packet body.  In any case, it uses its current index to generate the
pseudo-header that will be used to compute the HMAC and shipping out the
packet.  (This implies that a packet must be parsed in its entirety before
HMAC validation, which requires a robust parser.)</t>

<t>Packet reception is modified as follows.  Before checking the HMAC of
a packet, the receiver checks whether the packet contains an explicit
index.  If this is the case, it uses the index contained in the packet in
order to generate the pseudo header; if this is not the case, it uses the
index contained in its neighbours table.  If there is no index available
for that neighbour (either because the table doesn't contain in an entry for
this neighbour, or the entry doesn't contain an index), HMAC validation
fails.</t>

<t>The index and cryptographic seqno contained in the neighbours table are
only updated after HMAC validation has succeeded.</t>

<t>Since it is now impossible to differenciate between a failed HMAC and
an index change, a node must send a challenge whenever HMAC validation
fails.  This implies that spoofed packets cause a spurious challenge, but
that doesn't change the security properties of the protocol much, given
that in any case replayed packets can be used to cause a spurious
challenge.</t>
  
</section>

</back>

</rfc>
